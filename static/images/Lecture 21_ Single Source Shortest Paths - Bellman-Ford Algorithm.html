<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
    <title>Lecture 21: Single Source Shortest Paths - Bellman-Ford Algorithm</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/cs360.css" type="text/css">
</head>
<body>
  <div id="container">
    <div id="top">
	<h1><img src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/YCPLogo.png" alt="YCP Logo">&nbsp;Lecture 21: Single Source Shortest Paths - Bellman-Ford Algorithm</h1>
    </div>

	<div id="nav">
	    <ul>
	        <li><a href="http://faculty.ycp.edu/%7Edbabcock/cs360/index.html">CS 360</a></li>
<li>→</li>
<li><a href="http://faculty.ycp.edu/%7Edbabcock/cs360/lectures/index.html">Lecture Notes</a></li>
<li>→</li>
<li>Lecture 21</li>

	    </ul>
	</div>

    <div id="fullContent">

        <div class="document">
<p>MST solves the problem of finding a minimum total weight subset of 
edges that spans all the vertices. Another common graph problem is to 
find the shortest paths to all reachable vertices from a given source. 
We have already seen how to solve this problem in the case where all the
 edges have the <em>same</em> weight (in which case the shortest path is simply the minimum <em>number</em> of edges) using BFS. Now we will examine two algorithms for finding <em>single source shortest paths</em> for directed graphs when the edges have <em>different</em> weights - Bellman-Ford and Dijkstra's algorithms. Several related problems are:</p>
<blockquote>
<ul class="simple">
<li>Single destination shortest path - find the transpose graph (i.e. 
reverse the edge directions) and use single source shortest path</li>
<li>Single pair shortest path (i.e. a specific destination) - 
asymptotically this problem can be solved no faster than simply using 
single source shortest path algorithms to all the vertices</li>
<li>All pair shortest paths - one technique is to use single source 
shortest path for each vertex, but later we will see a more efficient 
algorithm</li>
</ul>
</blockquote>
<div class="section" id="single-source-shortest-path">
<h2>Single Source Shortest Path</h2>
<p><strong>Problem</strong></p>
<p>Given a directed graph <em>G(V,E)</em> with <em>weighted edges</em> <em>w(u,v)</em>, define the <em>path weight</em> of a path <em>p</em> as</p>
<blockquote>
<img alt="images/lecture21/pathweight.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/pathweight.png">
</blockquote>
<p>For a given source vertex <em>s</em>, find the <em>minimum weight paths</em> to every vertex reachable from <em>s</em> denoted</p>
<blockquote>
<img alt="images/lecture21/minpathweight.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/minpathweight.png">
</blockquote>
<p>The final solution will satisfy certain caveats:</p>
<blockquote>
<ul class="simple">
<li>The graph cannot contain any <em>negative weight cycles</em> 
(otherwise there would be no minimum path since we could simply continue
 to follow the negative weight cycle producing a path weight of -∞).</li>
<li>The solution cannot have any <em>positive weight cycles</em> (since the cycle could simply be removed giving a lower weight path).</li>
<li>The solution can be assumed to have no zero weight cycles (since they would not affect the minimum value).</li>
</ul>
</blockquote>
<p>Therefore given these caveats, we know the shortest paths must be <em>acyclic</em> (with ≤ |<em>V</em>| distinct vertices) ⇒ ≤ |<em>V</em>| - 1 edges in each path.</p>
<p><strong>Generic Algorithm</strong></p>
<p>The single source shortest path algorithms use the same notation as BFS (see <a class="reference external" href="http://faculty.ycp.edu/%7Edbabcock/cs360/lectures/lecture17.html">lecture 17</a>) with predecessor π and distance <em>d</em> fields for each vertex. The optimal solution will have <em>v.d</em> = δ(<em>s</em>,<em>v</em>) for all <em>v</em> ∈ <em>V</em>.</p>
<p>The solutions utilize the concept of <em>edge relaxation</em> which is a test to determine whether going through edge (<em>u</em>,<em>v</em>) reduces the distance to <em>v</em> and if so update <em>v.</em>π and <em>v.d</em>. This is accomplished using the condition</p>
<blockquote>
<img alt="images/lecture21/relaxation.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/relaxation.png">
</blockquote>
</div>
<div class="section" id="bellman-ford-algorithm">
<h2>Bellman-Ford Algorithm</h2>
<p>The <em>Bellman-Ford algorithm</em> uses relaxation to find single source shortest paths on directed graphs that may contain <em>negative weight edges</em>. The algorithm will also detect if there are any <em>negative weight cycles</em> (such that there is no solution).</p>
<pre class="literal-block">BELLMAN-FORD(G,w,s)
1.  INITIALIZE-SINGLE-SOURCE(G,s)
2.  for i = 1 to |G.V|-1
3.     for each edge (u,v) ∈ G.E
4.        RELAX(u,v,w)
5.  for each edge (u,v) ∈ G.E
6.     if v.d &gt; u.d + w(u,v)
7.        return FALSE
8.  return TRUE

INITIALIZE-SINGLE-SOURCE(G,s)
1.  for each vertex v ∈ G.V
2.     v.d = ∞
3.     v.pi = NIL
4.  s.d = 0

RELAX(u,v,w)
1.  if v.d &gt; u.d + w(u,v)
2.     v.d = u.d + w(u,v)
3.     v.pi = u
</pre>
<p>Basically the algorithm works as follows:</p>
<blockquote>
<ol class="arabic simple">
<li>Initialize <em>d</em>'s, π's, and set <em>s.d</em> = 0 ⇒ O(<em>V</em>)</li>
<li>Loop |<em>V</em>|-1 times through all edges checking the relaxation condition to compute minimum distances ⇒ (|<em>V</em>|-1) O(<em>E</em>) = O(<em>VE</em>)</li>
<li>Loop through all edges checking for negative weight cycles which occurs if any of the relaxation conditions fail ⇒ O(<em>E</em>)</li>
</ol>
</blockquote>
<p>The run time of the Bellman-Ford algorithm is O(<em>V</em> + <em>VE</em> + <em>E</em>) = O(<em>VE</em>).</p>
<p>Note that if the graph is a DAG (and thus is known to not have any cycles), we can make Bellman-Ford more efficient by first <em>topologically sorting</em> <em>G</em> (O(<em>V</em>+<em>E</em>)), performing the same initialization (O(<em>V</em>)), and then simply looping through each vertex <em>u</em> <em>in topological order</em> relaxing only the edges in Adj[<em>u</em>] (O(<em>E</em>)). This method only takes O(<em>V</em> + <em>E</em>) time. This procedure (with a few slight modifications) is useful for finding <em>critical paths</em> for PERT charts.</p>
<p><strong>Example</strong></p>
<p>Given the following directed graph</p>
<blockquote>
<img alt="images/lecture21/BellFordexample.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample.png">
</blockquote>
<p>Using vertex 5 as the source (setting its distance to 0), we initialize all the other distances to ∞.</p>
<blockquote>
<img alt="images/lecture21/BellFordexample1.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample1.png">
</blockquote>
<p><em>Iteration 1</em>: Edges (<em>u</em><sub>5</sub>,<em>u</em><sub>2</sub>) and (<em>u</em><sub>5</sub>,<em>u</em><sub>4</sub>) relax updating the distances to 2 and 4</p>
<blockquote>
<img alt="images/lecture21/BellFordexample2.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample2.png">
</blockquote>
<p><em>Iteration 2</em>: Edges (<em>u</em><sub>2</sub>,<em>u</em><sub>1</sub>), (<em>u</em><sub>4</sub>,<em>u</em><sub>2</sub>) and (<em>u</em><sub>4</sub>,<em>u</em><sub>3</sub>) relax updating the distances to 1, 2, and 4 respectively. Note edge (<em>u</em><sub>4</sub>,<em>u</em><sub>2</sub>) finds a shorter path to vertex 2 by going through vertex 4</p>
<blockquote>
<img alt="images/lecture21/BellFordexample3.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample3.png">
</blockquote>
<p><em>Iteration 3</em>: Edge (<em>u</em><sub>2</sub>,<em>u</em><sub>1</sub>) relaxes (since a shorter path to vertex 2 was found in the previous iteration) updating the distance to 1</p>
<blockquote>
<img alt="images/lecture21/BellFordexample4.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample4.png">
</blockquote>
<p><em>Iteration 4</em>: No edges relax</p>
<blockquote>
<img alt="images/lecture21/BellFordexample5.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample5.png">
</blockquote>
<p>The final shortest paths from vertex 5 with corresponding distances is</p>
<blockquote>
<img alt="images/lecture21/BellFordexample6.png" class="align-center" src="Lecture%2021:%20Single%20Source%20Shortest%20Paths%20-%20Bellman-Ford%20Algorithm_files/BellFordexample6.png">
</blockquote>
<p><em>Negative cycle checks</em>: We now check the relaxation condition
 one additional time for each edge. If any of the checks pass then there
 exists a negative weight cycle in the graph.</p>
<blockquote>
<p><em>v</em><sub>3</sub><em>.d</em> &gt; <em>u</em><sub>1</sub><em>.d</em> + <em>w</em>(1,3) ⇒ 4 ≯ 6 + 6 = 12 ✓</p>
<p><em>v</em><sub>4</sub><em>.d</em> &gt; <em>u</em><sub>1</sub><em>.d</em> + <em>w</em>(1,4) ⇒ 2 ≯ 6 + 3 = 9 ✓</p>
<p><em>v</em><sub>1</sub><em>.d</em> &gt; <em>u</em><sub>2</sub><em>.d</em> + <em>w</em>(2,1) ⇒ 6 ≯ 3 + 3 = 6 ✓</p>
<p><em>v</em><sub>4</sub><em>.d</em> &gt; <em>u</em><sub>3</sub><em>.d</em> + <em>w</em>(3,4) ⇒ 2 ≯ 3 + 2 = 5 ✓</p>
<p><em>v</em><sub>2</sub><em>.d</em> &gt; <em>u</em><sub>4</sub><em>.d</em> + <em>w</em>(4,2) ⇒ 3 ≯ 2 + 1 = 3 ✓</p>
<p><em>v</em><sub>3</sub><em>.d</em> &gt; <em>u</em><sub>4</sub><em>.d</em> + <em>w</em>(4,3) ⇒ 3 ≯ 2 + 1 = 3 ✓</p>
<p><em>v</em><sub>2</sub><em>.d</em> &gt; <em>u</em><sub>5</sub><em>.d</em> + <em>w</em>(5,2) ⇒ 3 ≯ 0 + 4 = 4 ✓</p>
<p><em>v</em><sub>4</sub><em>.d</em> &gt; <em>u</em><sub>5</sub><em>.d</em> + <em>w</em>(5,4) ⇒ 2 ≯ 0 + 2 = 2 ✓</p>
</blockquote>
<p>Note that for the edges <em>on the shortest paths</em> the relaxation criteria gives equalities.</p>
<p>Additionally, the path to any reachable vertex can be found by 
starting at the vertex and following the π's back to the source. For 
example, starting at vertex 1, <em>u</em><sub>1</sub>.π = 2, <em>u</em><sub>2</sub>.π = 4, <em>u</em><sub>4</sub>.π = 5 ⇒ the shortest path to vertex 1 is {5,4,2,1}.</p>
</div>
</div>

        </div>

    <div id="footer">
    &nbsp;
    </div>
  </div>


</body></html>